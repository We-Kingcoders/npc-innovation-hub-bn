/**
 * Password Utilities
 * Secure password handling for Innovation Hub
 * 
 * Last updated: 2025-07-01 15:21:30 UTC
 * Updated by: Alain275
 */

import bcrypt from 'bcrypt';
import crypto from 'crypto';

// Configuration
const SALT_ROUNDS = 12; // Industry standard in 2025, increased from 10
const MIN_PASSWORD_LENGTH = 8;
const PASSWORD_PATTERN = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/;

// Types
export interface PasswordValidationResult {
  isValid: boolean;
  errors: string[];
}

/**
 * Hash a plaintext password using bcrypt
 * @param password Plaintext password to hash
 * @returns Hashed password
 */
export async function hashPassword(password: string): Promise<string> {
    console.log(`[${new Date().toISOString()}] Password hashing requested`);
    const salt = await bcrypt.genSalt(SALT_ROUNDS);
    const hash = await bcrypt.hash(password, salt);
    return hash;
}

/**
 * Compare a plaintext password with a hashed password
 * @param password Plaintext password to check
 * @param hashedPassword Hashed password to compare against
 * @returns Boolean indicating if passwords match
 */
export const comparePassword = async (password: string, hashedPassword: string): Promise<boolean> => {
    return await bcrypt.compare(password, hashedPassword);
};

/**
 * Validate password strength according to security requirements
 * @param password Password to validate
 * @returns Validation result with boolean and error messages
 */
export const validatePasswordStrength = (password: string): PasswordValidationResult => {
    const errors: string[] = [];
    
    if (!password || password.length < MIN_PASSWORD_LENGTH) {
        errors.push(`Password must be at least ${MIN_PASSWORD_LENGTH} characters long`);
    }
    
    if (!PASSWORD_PATTERN.test(password)) {
        errors.push('Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character');
    }
    
    return {
        isValid: errors.length === 0,
        errors
    };
};

/**
 * Generate a secure random password
 * @param length Length of the password to generate (default: 12)
 * @returns Secure random password
 */
export const generateSecurePassword = (length: number = 12): string => {
    // Define character sets
    const uppercaseChars = 'ABCDEFGHJKLMNPQRSTUVWXYZ'; // Removed confusing characters like I and O
    const lowercaseChars = 'abcdefghijkmnopqrstuvwxyz'; // Removed confusing characters like l
    const numberChars = '23456789'; // Removed confusing characters like 0 and 1
    const specialChars = '@#$%&*+?!';
    const allChars = uppercaseChars + lowercaseChars + numberChars + specialChars;
    
    // Generate the base password with at least one of each character type
    let password = '';
    password += uppercaseChars.charAt(Math.floor(Math.random() * uppercaseChars.length));
    password += lowercaseChars.charAt(Math.floor(Math.random() * lowercaseChars.length));
    password += numberChars.charAt(Math.floor(Math.random() * numberChars.length));
    password += specialChars.charAt(Math.floor(Math.random() * specialChars.length));
    
    // Fill the rest of the password
    for (let i = password.length; i < length; i++) {
        password += allChars.charAt(Math.floor(Math.random() * allChars.length));
    }
    
    // Shuffle the password to make it more random
    password = password.split('').sort(() => 0.5 - Math.random()).join('');
    
    console.log(`[${new Date().toISOString()}] Secure password generated by ${process.env.NODE_ENV === 'development' ? 'Alain275' : 'system'}`);
    
    return password;
};

/**
 * Create a hash of a string (for tokens, etc.)
 * @param data String to hash
 * @returns SHA-256 hash of the string
 */
export const createHash = (data: string): string => {
    return crypto.createHash('sha256').update(data).digest('hex');
};

// Log module initialization
console.log(`[2025-07-01 15:21:30] Password utils initialized by Alain275`);